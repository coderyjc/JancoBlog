<!DOCTYPE html><html><head><meta charset="utf-8"><title>线性表的链式表示</title>    <link rel="stylesheet" href="../js/editor.md/css/editormd.min.css">   <script src="../js/jquery-1.12.js" type="text/javascript" charset="utf-8"></script>
   <script src="../js/article-preload.js" type="text/javascript" charset="utf-8"></script>
<link rel="stylesheet" href="../css/article.css"></head><body><!-- 导航条 --><div class="nav">    <!-- 回主页的"图标" -->    <a href="../../index.jsp" class="back-to-index">JancoBlog</a></div><!-- 所属分类 --><div class="article-sort"></div><!-- 标题栏 --><h1 class="article-title">线性表的链式表示</h1><!-- 作者栏 --><div class="article-info"><div class="article-author">作者：Jancoyan</div><div class="article-submit-time">发布时间：2021-05-06 21:15:07</div><div class="article-view-time"></div></div><div class="article-content"><div class="markdown-body editormd-preview-container" previewcontainer="true" style="padding: 20px;"><h1 id="h1-u7EBFu6027u8868u7684u94FEu5F0Fu8868u793A"><a name="线性表的链式表示" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线性表的链式表示</h1><h2 id="h2-u7EBFu6027u8868u7684u7B80u5355u64CDu4F5C"><a name="线性表的简单操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线性表的简单操作</h2><h3 id="h3-u524Du63D0"><a name="前提" class="reference-link"></a><span class="header-link octicon octicon-link"></span>前提</h3><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c++"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">LNode</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">    </span><span class="typ">ElemType</span><span class="pln"> data</span><span class="pun">;</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">LNode</span><span class="pun">*</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L3"><code class="lang-c++"><span class="pun">}</span><span class="typ">Lnode</span><span class="pun">,</span><span class="pln"> </span><span class="pun">*</span><span class="typ">LinkList</span><span class="pun">;</span></code></li><li class="L4"><code class="lang-c++"><span class="com">// 注意 LNode 为变量名, LinkList 为指针</span></code></li><li class="L5"><code class="lang-c++"></code></li><li class="L6"><code class="lang-c++"><span class="typ">Status</span><span class="pln"> </span><span class="typ">InitList_L</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">L</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="com">//建立头结点, 其 next 值为空</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">    L </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">)</span><span class="pln">malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="typ">LNode</span><span class="pun">));</span></code></li><li class="L9"><code class="lang-c++"><span class="pln">    L</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L0"><code class="lang-c++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> OK</span><span class="pun">;</span></code></li><li class="L1"><code class="lang-c++"><span class="pun">}</span></code></li><li class="L2"><code class="lang-c++"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<p>在这里我们定义了一个节点结构, 结构由两部分组成, 数据域和指针域, 其中, 数据域用来保存数据, 指针域用来指向下一个节点在这里我们学习的是带有头结点的指针.<br>要注意的是, 头结点的数据域通常不保存数据, 也就是说, 头结点的作用就是, 保存第一个节点的位置.<br>在单链表中, 头结点没有指针指向, 最后一个节点的指针域指向空NULL.<br>所以在单链表中, 不是所有的节点都有前驱或者后继.</p>
<h3 id="h3--i-"><a name="获得第 i 个元素" class="reference-link"></a><span class="header-link octicon octicon-link"></span>获得第 i 个元素</h3><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c"><span class="typ">Status</span><span class="pln"> </span><span class="typ">GetElem_L</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ElemType</span><span class="pun">&amp;</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L1"><code class="lang-c"><span class="pun">{</span></code></li><li class="L2"><code class="lang-c"><span class="pln">    </span><span class="com">//L 为带有头结点的单链表的头指针</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="com">// 当第 i 个元素存在的时候, 将值传给 e 返回OK, 否则返回 Error</span></code></li><li class="L4"><code class="lang-c"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">-&gt;</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    </span><span class="typ">int</span><span class="pln"> counter </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;&amp;</span><span class="pln"> counter </span><span class="pun">&lt;</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">// 当 p 非空且 不到第 i 个元素</span></code></li><li class="L7"><code class="lang-c"><span class="pln">        p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c"><span class="pln">        counter</span><span class="pun">++;</span></code></li><li class="L9"><code class="lang-c"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code class="lang-c"><span class="pln">    </span><span class="com">//在最后一次循环的时候 counter 会加到 counter = i</span></code></li><li class="L1"><code class="lang-c"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">p </span><span class="pun">||</span><span class="pln"> counter </span><span class="pun">&gt;</span><span class="pln"> i</span><span class="pun">)</span></code></li><li class="L2"><code class="lang-c"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> ERROR</span><span class="pun">;</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="kwd">else</span></code></li><li class="L4"><code class="lang-c"><span class="pln">        e </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> OK</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c"><span class="pun">}</span><span class="pln"> </span><span class="com">//GetElem_L</span></code></li><li class="L7"><code class="lang-c"></code></li><li class="L8"><code class="lang-c"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<p>这里说一下为什么有第12行的判定 :</p>
<p>如果我们传入的 i 值大于表中已有的元素的数量, 那么在第7行的while循环中, 会因为p指到了表的末尾, 为空而退出循环, 这时候, 我们在 12 行判定 p 为空,  返回ERROR.</p>
<p> 如果我们传入的 i 为一个非正整数, 即 小于等于0 的数, 表中不可能存在这个位置, 所以在第7行的判定中不会进入循环, 在12行的时候, counter 大于 i 的值, 也会返回 ERROR.</p>
<h3 id="h3-u63D2u5165u524Du7F6Eu5143u7D20"><a name="插入前置元素" class="reference-link"></a><span class="header-link octicon octicon-link"></span>插入前置元素</h3><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c"><span class="typ">Status</span><span class="pln"> </span><span class="typ">ListInsert_L</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ElemType</span><span class="pun">&amp;</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L1"><code class="lang-c"><span class="pun">{</span></code></li><li class="L2"><code class="lang-c"><span class="pln">    </span><span class="com">// 在线性链表的第 i 个元素之前插入一个元素 e</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="com">// 首先我们创造出这个节点, 给它分配好存储空间</span></code></li><li class="L4"><code class="lang-c"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">)</span><span class="pln">malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="typ">LNode</span><span class="pun">));</span><span class="pln"> </span></code></li><li class="L5"><code class="lang-c"><span class="pln">    q</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span><span class="pln"> </span><span class="com">//数据域赋值</span></code></li><li class="L6"><code class="lang-c"><span class="pln">    </span><span class="typ">int</span><span class="pln"> counter </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L7"><code class="lang-c"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;&amp;</span><span class="pln"> counter </span><span class="pun">&lt;</span><span class="pln"> i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span></code></li><li class="L9"><code class="lang-c"><span class="pln">    </span><span class="pun">{</span></code></li><li class="L0"><code class="lang-c"><span class="pln">        p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L1"><code class="lang-c"><span class="pln">        counter</span><span class="pun">++;</span></code></li><li class="L2"><code class="lang-c"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="com">//循环结束之后, counter会等于 i - 1</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">counter </span><span class="pun">&gt;</span><span class="pln"> i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="pun">!</span><span class="pln">p</span><span class="pun">)</span></code></li><li class="L4"><code class="lang-c"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> ERROR</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    q</span><span class="pun">-&gt;</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c"><span class="pln">    p</span><span class="pun">-&gt;</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> q</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> OK</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c"><span class="pun">}</span><span class="com">// ListInsert_L</span></code></li><li class="L9"><code class="lang-c"></code></li><li class="L0"><code class="lang-c"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<p>第 14 行判定的原因同上.</p>
<p>16/17 行不可以颠倒, 如果颠倒了, 则q的指针域会指向自己.</p>
<h3 id="h3-u5220u9664"><a name="删除" class="reference-link"></a><span class="header-link octicon octicon-link"></span>删除</h3><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c++"><span class="typ">Status</span><span class="pln"> </span><span class="typ">ListDelete</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ElemType</span><span class="pun">&amp;</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L1"><code class="lang-c++"><span class="pun">{</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">    </span><span class="com">// 删除第 i 个元素, 并且以 e 的形式返回</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">;</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> counter </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;&amp;</span><span class="pln"> counter </span><span class="pun">&lt;</span><span class="pln"> i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">    </span><span class="pun">{</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">        p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">        counter</span><span class="pun">++;</span></code></li><li class="L9"><code class="lang-c++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code class="lang-c++"><span class="pln">    </span><span class="com">//循环结束之后, p 应该是 i-1 个位置上的元素</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">p </span><span class="pun">||</span><span class="pln"> counter </span><span class="pun">&gt;</span><span class="pln"> i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">        </span><span class="kwd">return</span><span class="pln"> ERROR</span><span class="pun">;</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">    </span><span class="com">// q 为待删除元素</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="com">//将 p-&gt;next 命名为 q</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> q</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">    e </span><span class="pun">=</span><span class="pln"> q</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">;</span><span class="pln"> </span><span class="com">//将q的数据域赋给 e</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> OK</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c++"><span class="pun">}</span></code></li><li class="L9"><code class="lang-c++"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<h3 id="h3--e-"><a name="返回值为 e 的元素的地址" class="reference-link"></a><span class="header-link octicon octicon-link"></span>返回值为 e 的元素的地址</h3><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c++"><span class="typ">LNode</span><span class="pun">*</span><span class="pln"> </span><span class="typ">ElemLocate</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ElemType</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L1"><code class="lang-c++"><span class="pun">{</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">    </span><span class="com">//返回 L 中第一个与 e 的值相同的元素的地址</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">L</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> ERROR</span><span class="pun">;</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;&amp;</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">!=</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">        p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c++"><span class="pun">}</span></code></li><li class="L9"><code class="lang-c++"></code></li><li class="L0"><code class="lang-c++"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<p>如果 没有找到的话, 循环结束之后 p 应该是 NULL,<br>如果 找到了, 循环结束之后, p-&gt;data 应该是 e<br>所以无论如何, 返回 p 都是对的</p>
<h2 id="h2-u7EBFu6027u94FEu8868u7684u590Du6742u64CDu4F5C"><a name="线性链表的复杂操作" class="reference-link"></a><span class="header-link octicon octicon-link"></span>线性链表的复杂操作</h2><h3 id="h3-u6709u5E8Fu94FEu8868u7684u5F52u5E76"><a name="有序链表的归并" class="reference-link"></a><span class="header-link octicon octicon-link"></span>有序链表的归并</h3><h4 id="h4-u6CD5u4E00"><a name="法一" class="reference-link"></a><span class="header-link octicon octicon-link"></span>法一</h4><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c++"><span class="com">//方法 1 : 将链表 B 归并到 链表 A</span></code></li><li class="L1"><code class="lang-c++"><span class="kwd">void</span><span class="pln"> </span><span class="typ">MergeList</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">La</span><span class="pun">,</span><span class="pln"> </span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">Lb</span><span class="pun">)</span></code></li><li class="L2"><code class="lang-c++"><span class="pun">{</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> pa </span><span class="pun">=</span><span class="pln"> </span><span class="typ">La</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> pb </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Lb</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> </span><span class="typ">La</span><span class="pun">;</span><span class="pln"> </span><span class="com">//pa 和 q 一定是在一条线上并且一前一后的关系</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">  </span><span class="com">//t 用来临时存储 pb 的前置元素,  pa 和 pb 是始终领队的</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">pa </span><span class="pun">&amp;&amp;</span><span class="pln"> pb</span><span class="pun">)</span><span class="pln"> </span><span class="com">//当pa和pb都没有到表尾</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">    </span><span class="pun">{</span></code></li><li class="L9"><code class="lang-c++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pa</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">&lt;=</span><span class="pln"> pb</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">)</span><span class="pln"> </span><span class="com">//如果pa不是第一个大于pb的元素</span></code></li><li class="L0"><code class="lang-c++"><span class="pln">        </span><span class="pun">{</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">            q </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">;</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">            pa </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">        </span><span class="pun">}</span><span class="pln"> </span><span class="com">// 使 pa 和 q 向 链表 a 的后面后移动一位</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">        </span><span class="kwd">else</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">        </span><span class="pun">{</span><span class="pln"> </span><span class="com">//pa指向的是第一个大于pb的元素, 这时候将pb指向的元素插入pa与q之间</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">            t </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">;</span><span class="pln"> </span><span class="com">//t 用来临时存储待查入变量</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">            pb </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="com">//pb 后移, 指向下一个节点</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">            </span><span class="com">// 将 t 指向的元素插入pa和q之间</span></code></li><li class="L9"><code class="lang-c++"><span class="pln">             t</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L0"><code class="lang-c++"><span class="pln">            q</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> t</span><span class="pun">;</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">             </span><span class="com">/*在将 t 指向的元素插入到了 a 中之后, 这个元素就成了a中的元素, </span></code></li><li class="L2"><code class="lang-c++"><span class="com">             并且在 pa 的前面, q 的后面, 我们要让 pa 与 q 一前一后, 因此我们把 q 指向了 t */</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">            q </span><span class="pun">=</span><span class="pln"> t</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L4"><code class="lang-c++"><span class="pln">        </span><span class="pun">}</span><span class="pln"> </span><span class="com">// 循环结束的条件为 : pa 或 pb 到达了表尾</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pb</span><span class="pun">)</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">            q</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="lang-c++"><span class="pun">}</span></code></li><li class="L9"><code class="lang-c++"><span class="com">//代码来源 &lt;&lt;数据结构 习题集&gt;&gt; b站&lt;算法与数据结构`上交版 P4&gt;</span></code></li></ol></pre>
<p>归并原理 : 对于遍历过程中 b 中的每一个元素(假设为当前元素pb), 在 a 中从头开始寻找小于b中当前元素的最后一个元素, 插入到其后 , 或者大于当前元素的第一个元素,  插入到其前面.</p>
<p>pa 和 q : 我们在对链表a进行遍历的时候, 一定要有一对指针<strong>一前一后</strong>(pa 在前, q在后) 指向一对元素, 用来和 当前元素(pb) 进行比较, 如果 pa 大于当前元素, 另一个 q 小于当前元素, 则当前元素应该插入q 和 pa 指向元素的中间</p>
<p>pb 和 t : pb 指向链表 b 中<strong>当前的元素</strong>, 而 t 是在插入的过程中, 用来存储 pb 的前置元素的<strong>临时变量</strong>, pb 与 t 的关系也是一前(pb)一后(t)</p>
<h4 id="h4-u6CD5u4E8C"><a name="法二" class="reference-link"></a><span class="header-link octicon octicon-link"></span>法二</h4><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c++"><span class="com">//方法 2 : 将链表 A B 归并到链表 C</span></code></li><li class="L1"><code class="lang-c++"></code></li><li class="L2"><code class="lang-c++"><span class="kwd">void</span><span class="pln"> </span><span class="typ">MergeList</span><span class="pun">(</span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">La</span><span class="pun">,</span><span class="pln"> </span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">Lb</span><span class="pun">,</span><span class="pln"> </span><span class="typ">LinkList</span><span class="pun">&amp;</span><span class="pln"> </span><span class="typ">Lc</span><span class="pun">)</span></code></li><li class="L3"><code class="lang-c++"><span class="pun">{</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="com">// 已知单链线性表 La 和 Lb 的元素按照 值 非递减 排列</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    </span><span class="com">// 归并 La 和 Lb 得到新的单链线性表 Lc , Lc 的元素也按照 值 非递减排列</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> pa </span><span class="pun">=</span><span class="pln"> </span><span class="typ">La</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> pb </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Lb</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">    </span><span class="typ">LinkList</span><span class="pln"> pc </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Lc</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">La</span><span class="pun">;</span><span class="pln"> </span><span class="com">//把 La 的头结点作为 Lc 的头结点(把 Lb 的头结点作为 Lc 的头结点也可以, 因为都是空指针)</span></code></li><li class="L9"><code class="lang-c++"></code></li><li class="L0"><code class="lang-c++"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pa </span><span class="pun">&amp;&amp;</span><span class="pln"> pb</span><span class="pun">)</span><span class="pln"> </span><span class="com">//当pb和pa非空</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">    </span><span class="pun">{</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pa</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">&lt;=</span><span class="pln"> pb</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">)</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">        </span><span class="pun">{</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">            pc</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">;</span><span class="pln"> </span><span class="com">//将 pa 指向的元素与c的末尾链接</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">            pc </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">;</span><span class="pln"> </span><span class="com">//pc继续指向c表的末尾</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">            pa </span><span class="pun">=</span><span class="pln"> pa</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="com">//pa 后移</span></code></li><li class="L7"><code class="lang-c++"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L8"><code class="lang-c++"><span class="pln">        </span><span class="kwd">else</span></code></li><li class="L9"><code class="lang-c++"><span class="pln">        </span><span class="pun">{</span></code></li><li class="L0"><code class="lang-c++"><span class="pln">            pc</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">;</span></code></li><li class="L1"><code class="lang-c++"><span class="pln">            pc </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">;</span></code></li><li class="L2"><code class="lang-c++"><span class="pln">            pb </span><span class="pun">=</span><span class="pln"> pb</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L3"><code class="lang-c++"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L4"><code class="lang-c++"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L5"><code class="lang-c++"><span class="pln">    pc</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pa </span><span class="pun">?</span><span class="pln"> pa </span><span class="pun">:</span><span class="pln"> pb</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c++"><span class="pln">    free</span><span class="pun">(</span><span class="typ">Lb</span><span class="pun">);</span></code></li><li class="L7"><code class="lang-c++"><span class="pun">}</span></code></li><li class="L8"><code class="lang-c++"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<p>归并原理 : 创造出空节点 Lc , pc 指向Lc, Lc为头结点, pc作为中间变量, 总是指向c表的末尾, 我们要做的就是从 a b 表中从小到大 “<strong>挑选</strong>“ 元素, 然后按照顺序插入到 c 表中.pa 和 pb 总是指向 a 表和 b 表的第一个元素.</p>
<p>line 26 : 因为 pc 总是指向c表的末尾, 所以, pc-&gt;next == NULL;  所以这句话的意思是 : 判断 pa 是否为空, 空的话就让 pc 的 next 指向 pb , 非空就让其指向 pa.</p>
<h3 id="h3-u5FAAu73AFu94FEu8868"><a name="循环链表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>循环链表</h3><p>循环链表即 让链表表尾的节点的指针域指向链表的头节点其操作方法与单链表类似, 这里不再详谈.</p>
<h3 id="h3-u53CCu5411u94FEu8868"><a name="双向链表" class="reference-link"></a><span class="header-link octicon octicon-link"></span>双向链表</h3><h4 id="h4-u58F0u660E"><a name="声明" class="reference-link"></a><span class="header-link octicon octicon-link"></span>声明</h4><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c"><span class="com">// 双向链表</span></code></li><li class="L1"><code class="lang-c"></code></li><li class="L2"><code class="lang-c"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">DulLNode</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">DulLNode</span><span class="pun">*</span><span class="pln"> prior</span><span class="pun">;</span><span class="pln"> </span><span class="com">//指向该节点的前驱</span></code></li><li class="L4"><code class="lang-c"><span class="pln">    </span><span class="typ">ElemType</span><span class="pln"> data</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> </span><span class="typ">DulLNode</span><span class="pun">*</span><span class="pln"> next</span><span class="pun">;</span><span class="pln"> </span><span class="com">//指向该节点的后继</span></code></li><li class="L6"><code class="lang-c"><span class="pun">}</span><span class="typ">DulLNode</span><span class="pun">,</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="typ">DuLinkList</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c"></code></li><li class="L8"><code class="lang-c"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
<h4 id="h4--i-"><a name="在第 i 个节点前面插入" class="reference-link"></a><span class="header-link octicon octicon-link"></span>在第 i 个节点前面插入</h4><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="lang-c"><span class="typ">Status</span><span class="pln"> </span><span class="typ">LIstInsert_Dul</span><span class="pun">(</span><span class="typ">DuLinkList</span><span class="pun">&amp;</span><span class="pln"> L</span><span class="pun">,</span><span class="pln"> </span><span class="typ">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> </span><span class="typ">ElemType</span><span class="pun">&amp;</span><span class="pln"> e</span><span class="pun">)</span></code></li><li class="L1"><code class="lang-c"><span class="pun">{</span></code></li><li class="L2"><code class="lang-c"><span class="pln">    </span><span class="com">//在带有头结点的双向链表的第 i 个的位置之前插入元素 e</span></code></li><li class="L3"><code class="lang-c"><span class="pln">    </span><span class="typ">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L4"><code class="lang-c"><span class="pln">    </span><span class="typ">DuLinkList</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">&lt;</span><span class="pln"> i </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> p</span><span class="pun">)</span></code></li><li class="L6"><code class="lang-c"><span class="pln">    </span><span class="pun">{</span></code></li><li class="L7"><code class="lang-c"><span class="pln">        p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">next</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c"><span class="pln">        j</span><span class="pun">++;</span></code></li><li class="L9"><code class="lang-c"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="com">//当j == i - 1 的时候, p 指向了表中的第 i - 1 个元素</span></code></li><li class="L0"><code class="lang-c"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">p</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> ERROR</span><span class="pun">;</span><span class="pln"> </span><span class="com">//表的长度小于 1</span></code></li><li class="L1"><code class="lang-c"><span class="pln">    </span><span class="typ">DuLinkList</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">DuLinkList</span><span class="pun">)</span><span class="pln">malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="typ">ElemType</span><span class="pun">));</span><span class="pln"> </span><span class="com">// s 为新元素</span></code></li><li class="L2"><code class="lang-c"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">s</span><span class="pun">)</span><span class="pln"> exit</span><span class="pun">(</span><span class="pln">OVERFLOW</span><span class="pun">);</span><span class="pln"> </span><span class="com">//空间不够, 溢出</span></code></li><li class="L3"><code class="lang-c"></code></li><li class="L4"><code class="lang-c"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span></code></li><li class="L5"><code class="lang-c"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">prior </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="pln">prior</span><span class="pun">;</span></code></li><li class="L6"><code class="lang-c"><span class="pln">    p</span><span class="pun">-&gt;</span><span class="pln">prior</span><span class="pun">-&gt;</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">;</span></code></li><li class="L7"><code class="lang-c"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">next </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L8"><code class="lang-c"><span class="pln">    p</span><span class="pun">-&gt;</span><span class="pln">prior </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">;</span></code></li><li class="L9"><code class="lang-c"></code></li><li class="L0"><code class="lang-c"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> OK</span><span class="pun">;</span></code></li><li class="L1"><code class="lang-c"><span class="pun">}</span></code></li><li class="L2"><code class="lang-c"><span class="com">//代码来源 &lt;&lt;数据结构&gt;&gt; (清华大学出版社出版, 严蔚敏/吴伟民 编著)</span></code></li></ol></pre>
</div></div><div class="article-comment"><div class="comment-title">添加笔记</div> <hr><div class="comment-list"></div><div class="add-comment"><textarea maxlength="20" placeholder="昵称" id="edit-comment-author" rows="1" cols="110"></textarea><textarea maxlength="50" placeholder="邮箱" id="edit-comment-email" rows="1" cols="110"></textarea><textarea maxlength="1000" placeholder="笔记" id="edit-comment-content" rows="5" cols="110"></textarea><button class="add-comment-btn">添加</button></div></div></body></html>